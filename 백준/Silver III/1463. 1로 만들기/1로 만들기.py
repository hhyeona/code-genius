'''
1로 만들기.

1. x 가 3으로 나누어 떨어지면, 3으로 나눔. or 1 빼기
2. x 가 2로 나누어 떨어지면, 2로 나눔. or 1 빼기
3. 1을 뺌.

위 3개를 사용하여 1을 만듦.
연산을 사용하는 횟수의 최솟값을 출력.

1 <= N <= 백만.

모든 입력 정수를 -1 함.
그 후, 최소한의 횟수로 0을 만들면 됨.

DP 이용.
상향식, 하향식이 있는데
처음에 두 수 ( N, 1) 를 알기 때문에 상향식으로 품.
상향식 : 제일 작은 인덱스의 수부터 목표값으로
하향식 : 맨 위의 값에서 재귀로 제일 작은 인덱스로 향함.

그리디는 최적의 방법이 반례없이 적용 될 때,
동적 계획법(DP)는 가능성을 모두 두고 그 안에 최솟값을 찾을 수 있음.

내가 처음 생각한 방식은 큰 수로 나누는 그리디였지만,
10-5-4-2-1 보다. 10-9-3-1 이 최솟값임.

메모제이션 방법을 사용해서 중복되는 계산값을 저장해 효율을 높여야 함.

또한, 위의 세가지 예시를 다 시도해 보아야 함. (if / not elif)

2부터 1이 되는 가지 수를 dp에 저장.
(계속 탑다운만 생각해버림..)

'''
n = int(input())
dp = [0] * (n+1) # index번호 맞추려고 +1 함.

for i in range(2, n+1): # 1은 이미 1이니까. 2부터.
    dp[i] = dp[i-1] + 1 # 그 이전 index애에서 -1 하는 가짓수 늘려줌.
    # -1 부터 하는 건, 2,3 안되는 경우 무조건 -1이니까.

    if i % 2 == 0: # 2로 나누어 떨어지면,
        dp[i] = min(dp[i], dp[i//2] + 1)
        # -1 한 것과, 나누기 2 한 것 중에 작은 가짓 수로 저장.
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i//3]+1)

print(dp[n])






